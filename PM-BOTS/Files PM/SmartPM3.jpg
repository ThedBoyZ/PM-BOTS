/*
  FirmataParser.cpp
  Copyright (c) 2006-2008 Hans-Christoph Steiner.  All rights reserved.
  Copyright (C) 2009-2016 Jeff Hoefs.  All rights reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  See file LICENSE.txt for further informations on licensing terms.
*/

//******************************************************************************
//* Includes
//******************************************************************************

#include "FirmataParser.h"

#include "FirmataConstants.h"

using namespace firmata;

//******************************************************************************
//* Constructors
//******************************************************************************

/**
 * The FirmataParser class.
 * @param dataBuffer A pointer to an external buffer used to store parsed data
 * @param dataBufferSize The size of the external buffer
 */
FirmataParser::FirmataParser(uint8_t * const dataBuffer, size_t dataBufferSize)
:
  dataBuffer(dataBuffer),
  dataBufferSize(dataBufferSize),
  executeMultiByteCommand(0),
  multiByteChannel(0),
  waitForData(0),
  parsingSysex(false),
  sysexBytesRead(0),
  currentAnalogCallbackContext((void *)NULL),
  currentDigitalCallbackContext((void *)NULL),
  currentReportAnalogCallbackContext((void *)NULL),
  currentReportDigitalCallbackContext((void *)NULL),
  currentPinModeCallbackContext((void *)NULL),
  currentPinValueCallbackContext((void *)NULL),
  currentReportFirmwareCallbackContext((void *)NULL),
  currentReportVersionCallbackContext((void *)NULL),
  currentDataBufferOverflowCallbackContext((void *)NULL),
  currentStringCallbackContext((void *)NULL),
  currentSysexCallbackContext((void *)NULL),
  currentSystemResetCallbackContext((void *)NULL),
  currentAnalogCallback((callbackFunction)NULL),
  currentDigitalCallback((callbackFunction)NULL),
  currentReportAnalogCallback((callbackFunction)NULL),
  currentReportDigitalCallback((callbackFunction)NULL),
  currentPinModeCallback((callbackFunction)NULL),
  currentPinValueCallback((callbackFunction)NULL),
  currentDataBufferOverflowCallback((dataBufferOverflowCallbackFunction)NULL),
  currentStringCallback((stringCallbackFunction)NULL),
  currentSysexCallback((sysexCallbackFunction)NULL),
  currentReportFirmwareCallback((versionCallbackFunction)NULL),
  currentReportVersionCallback((systemCallbackFunction)NULL),
  currentSystemResetCallback((systemCallbackFunction)NULL)
{
    allowBufferUpdate = ((uint8_t *)NULL == dataBuffer);
}

//******************************************************************************
//* Public Methods
//******************************************************************************

//------------------------------------------------------------------------------
// Serial Receive Handling

/**
 * Parse data from the input stream.
 * @param inputData A single byte to be added to the parser.
 */
void FirmataParser::parse(uint8_t inputData)
{
  uint8_t command;

  if (parsingSysex) {
    if (inputData == END_SYSEX) {
      //stop sysex byte
      parsingSysex = false;
      //fire off handler function
      processSysexMessage();
    } else {
      //normal data byte - add to buffer
      bufferDataAtPosition(inputData, sysexBytesRead);
      ++sysexBytesRead;
    }
  } else if ( (waitForData > 0) && (inputData < 128) ) {
    --waitForData;
    bufferDataAtPosition(inputData, waitForData);
    if ( (waitForData == 0) && executeMultiByteCommand ) { // got the whole message
      switch (executeMultiByteCommand) {
        case ANALOG_MESSAGE:
          if (currentAnalogCallback) {
            (*currentAnalogCallback)(currentAnalogCallbackContext,
                                     multiByteChannel,
                                     (dataBuffer[0] << 7)
                                     + dataBuffer[1]);
          }
          break;
        case DIGITAL_MESSAGE:
          if (currentDigitalCallback) {
            (*currentDigitalCallback)(currentDigitalCallbackContext,
                                      multiByteChannel,
                                      (dataBuffer[0] << 7)
                                      + dataBuffer[1]);
          }
          break;
        case SET_PIN_MODE:
          if (currentPinModeCallback)
            (*currentPinModeCallback)(currentPinModeCallbackContext, dataBuffer[1], dataBuffer[0]);
          break;
        case SET_DIGITAL_PIN_VALUE:
          if (currentPinValueCallback)
            (*currentPinValueCallback)(currentPinValueCallbackContext, dataBuffer[1], dataBuffer[0]);
          break;
        case REPORT_ANALOG:
          if (currentReportAnalogCallback)
            (*currentReportAnalogCallback)(currentReportAnalogCallbackContext, multiByteChannel, dataBuffer[0]);
          break;
        case REPORT_DIGITAL:
          if (currentReportDigitalCallback)
            (*currentReportDigitalCallback)(currentReportDigitalCallbackContext, multiByteChannel, dataBuffer[0]);
          break;
      }
      executeMultiByteCommand = 0;
    }
  } else {
    // remove channel info from command byte if less than 0xF0
    if (inputData < 0xF0) {
      command = inputData & 0xF0;
      multiByteChannel = inputData & 0x0F;
    } else {
      command = inputData;
      // commands in the 0xF* range don't use channel data
    }
    switch (command) {
      case ANALOG_MESSAGE:
      case DIGITAL_MESSAGE:
      case SET_PIN_MODE:
      case SET_DIGITAL_PIN_VALUE:
        waitForData = 2; // two data bytes needed
        executeMultiByteCommand = command;
        break;
      case REPORT_ANALOG:
      case REPORT_DIGITAL:
        waitForData = 1; // one data byte needed
        executeMultiByteCommand = command;
        break;
      case START_SYSEX:
        parsingSysex = true;
        sysexBytesRead = 0;
        break;
      case SYSTEM_RESET:
        systemReset();
        break;
      case REPORT_VERSION:
        if (currentReportVersionCallback)
          (*currentReportVersionCallback)(currentReportVersionCallbackContext);
        break;
    }
  }
}

/**
 * @return Returns true if the parser is actively parsing data.
 */
bool FirmataParser::isParsingMessage(void)
const
{
  return (waitForData > 0 || parsingSysex);
}

/**
 * Provides a mechanism to either set or update the working buffer of the parser.
 * The method will be enabled when no buffer has been provided, or an overflow
 * condition exists.
 * @param dataBuffer A pointer to an external buffer used to store parsed data
 * @param dataBufferSize The size of the external buffer
 */
int FirmataParser::setDataBufferOfSize(uint8_t * dataBuffer, size_t dataBufferSize)
{
    int result;

    if ( !allowBufferUpdate ) {
      result = __LINE__;
    } else if ((uint8_t *)NULL == dataBuffer) {
      result = __LINE__;
    } else {
      this->dataBuffer = dataBuffer;
      this->dataBufferSize = dataBufferSize;
      allowBufferUpdate = false;
      result = 0;
    }

    return result;
}

/**
 * Attach a generic sysex callback function to a command (options are: ANALOG_MESSAGE,
 * DIGITAL_MESSAGE, REPORT_ANALOG, REPORT DIGITAL, SET_PIN_MODE and SET_DIGITAL_PIN_VALUE).
 * @param command The ID of the command to attach a callback function to.
 * @param newFunction A reference to the callback function to attach.
 * @param context An optional context to be provided to the callback function (NULL by default).
 * @note The context parameter is provided so you can pass a parameter, by reference, to
 *       your callback function.
 */
void FirmataParser::attach(uint8_t command, callbackFunction newFunction, void * context)
{
  switch (command) {
    case ANALOG_MESSAGE:
      currentAnalogCallback = newFunction;
      currentAnalogCallbackContext = context;
      break;
    case DIGITAL_MESSAGE:
      currentDigitalCallback = newFunction;
      currentDigitalCallbackContext = context;
      break;
    case REPORT_ANALOG:
      currentReportAnalogCallback = newFunction;
      currentReportAnalogCallbackContext = context;
      break;
    case REPORT_DIGITAL:
      currentReportDigitalCallback = newFunction;
      currentReportDigitalCallbackContext = context;
      break;
    case SET_PIN_MODE:
      currentPinModeCallback = newFunction;
      currentPinModeCallbackContext = context;
      break;
    case SET_DIGITAL_PIN_VALUE:
      currentPinValueCallback = newFunction;
      currentPinValueCallbackContext = context;
      break;
  }
}

/**
 * Attach a version callback function (supported option: REPORT_FIRMWARE).
 * @param command The ID of the command to attach a callback function to.
 * @param newFunction A reference to the callback function to attach.
 * @param context An optional context to be provided to the callback function (NULL by default).
 * @note The context parameter is provided so you can pass a parameter, by reference, to
 *       your callback function.
 */
void FirmataParser::attach(uint8_t command, versionCallbackFunction newFunction, void * context)
{
  switch (command) {
    case REPORT_FIRMWARE:
      currentReportFirmwareCallback = newFunction;
      currentReportFirmwareCallbackContext = context;
      break;
  }
}

/**
 * Attach a system callback function (supported options are: SYSTEM_RESET, REPORT_VERSION).
 * @param command The ID of the command to attach a callback function to.
 * @param newFunction A reference to the callback function to attach.
 * @param context An optional context to be provided to the callback function (NULL by default).
 * @note The context parameter is provided so you can pass a parameter, by reference, to
 *       your callback function.
 */
void FirmataParser::attach(uint8_t command, systemCallbackFunction newFunction, void * context)
{
  switch (command) {
    case REPORT_VERSION:
      currentReportVersionCallback = newFunction;
      currentReportVersionCallbackContext = context;
      break;
    case SYSTEM_RESET:
      currentSystemResetCallback = newFunction;
      currentSystemResetCallbackContext = context;
      break;
  }
}

/**
 * Attach a callback function for the STRING_DATA command.
 * @param command Must be set to STRING_DATA or it will be ignored.
 * @param newFunction A reference to the string callback function to attach.
 * @param context An optional context to be provided to the callback function (NULL by default).
 * @note The context parameter is provided so you can pass a parameter, by reference, to
 *       your callback function.
 */
void FirmataParser::attach(uint8_t command, stringCallbackFunction newFunction, void * context)
{
  switch (command) {
    case STRING_DATA:
      currentStringCallback = newFunction;
      currentStringCallbackContext = context;
      break;
  }
}

/**
 * Attach a generic sysex callback function to sysex command.
 * @param command The ID of the command to attach a callback function to.
 * @param newFunction A reference to the sysex callback function to attach.
 * @param context An optional context to be provided to the callback function (NULL by default).
 * @note The context parameter is provided so you can pass a parameter, by reference, to
 *       your callback function.
 */
void FirmataParser::attach(uint8_t command, sysexCallbackFunction newFunction, void * context)
{
  (void)command;
  currentSysexCallback = newFunction;
  currentSysexCallbackContext = context;
}

/**
 * Attach a buffer overflow callback
 * @param newFunction A reference to the buffer overflow callback function to attach.
 * @param context An optional context to be provided to the callback function (NULL by default).
 * @note The context parameter is provided so you can pass a parameter, by reference, to
 *       your callback function.
 */
void FirmataParser::attach(dataBufferOverflowCallbackFunction newFunction, void * context)
{
  currentDataBufferOverflowCallback = newFunction;
  currentDataBufferOverflowCallbackContext = context;
}

/**
 * Detach a callback function for a specified command (such as SYSTEM_RESET, STRING_DATA,
 * ANALOG_MESSAGE, DIGITAL_MESSAGE, etc).
 * @param command The ID of the command to detatch the callback function from.
 */
void FirmataParser::detach(uint8_t command)
{
  switch (command) {
    case REPORT_FIRMWARE:
      attach(command, (versionCallbackFunction)NULL, NULL);
      break;
    case REPORT_VERSION:
    case SYSTEM_RESET:
      attach(command, (systemCallbackFunction)NULL, NULL);
      break;
    case STRING_DATA:
      attach(command, (stringCallbackFunction)NULL, NULL);
      break;
    case START_SYSEX:
      attach(command, (sysexCallbackFunction)NULL, NULL);
      break;
    default:
      attach(command, (callbackFunction)NULL, NULL);
      break;
  }
}

/**
 * Detach the buffer overflow callback
 * @param <unused> Any pointer of type dataBufferOverflowCallbackFunction.
 */
void FirmataParser::detach(dataBufferOverflowCallbackFunction)
{
  currentDataBufferOverflowCallback = (dataBufferOverflowCallbackFunction)NULL;
  currentDataBufferOverflowCallbackContext = (void *)NULL;
}

//******************************************************************************
//* Private Methods
//******************************************************************************

/**
 * Buffer abstraction to prevent memory corruption
 * @param data The byte to put into the buffer
 * @param pos The position to insert the byte into the buffer
 * @return writeError A boolean to indicate if an error occured
 * @private
 */
bool FirmataParser::bufferDataAtPosition(const uint8_t data, const size_t pos)
{
  bool bufferOverflow = (pos >= dataBufferSize);

  // Notify of overflow condition
  if ( bufferOverflow
  && ((dataBufferOverflowCallbackFunction)NULL != currentDataBufferOverflowCallback) )
  {
    allowBufferUpdate = true;
    currentDataBufferOverflowCallback(currentDataBufferOverflowCallbackContext);
    // Check if overflow was resolved during callback
    bufferOverflow = (pos >= dataBufferSize);
  }

  // Write data to buffer if no overflow condition persist
  if ( !bufferOverflow )
  {
    dataBuffer[pos] = data;
  }

  return bufferOverflow;
}

/**
 * Transform 7-bit firmata message into 8-bit stream
 * @param bytec The encoded data byte length of the message (max: 16383).
 * @param bytev A pointer to the encoded array of data bytes.
 * @return The length of the decoded data.
 * @note The conversion will be done in place on the provided buffer.
 * @private
 */
size_t FirmataParser::decodeByteStream(size_t bytec, uint8_t * bytev) {
  size_t decoded_bytes, i;

  for ( i = 0, decoded_bytes = 0 ; i < bytec ; ++decoded_bytes, ++i ) {
    bytev[decoded_bytes] = bytev[i];
    bytev[decoded_bytes] |= (uint8_t)(bytev[++i] << 7);
  }

  return decoded_bytes;
}

/**
 * Process incoming sysex messages. Handles REPORT_FIRMWARE and STRING_DATA internally.
 * Calls callback function for STRING_DATA and all other sysex messages.
 * @private
 */
void FirmataParser::processSysexMessage(void)
{
  switch (dataBuffer[0]) { //first byte in buffer is command
    case REPORT_FIRMWARE:
      if (currentReportFirmwareCallback) {
        const size_t major_version_offset = 1;
        const size_t minor_version_offset = 2;
        const size_t string_offset = 3;
        // Test for malformed REPORT_FIRMWARE message (used to query firmware prior to Firmata v3.0.0)
        if ( 3 > sysexBytesRead ) {
          (*currentReportFirmwareCallback)(currentReportFirmwareCallbackContext, 0, 0, (const char *)NULL);
        } else {
          const size_t end_of_string = (string_offset + decodeByteStream((sysexBytesRead - string_offset), &dataBuffer[string_offset]));
          bufferDataAtPosition('\0', end_of_string); // NULL terminate the string
          (*currentReportFirmwareCallback)(currentReportFirmwareCallbackContext, (size_t)dataBuffer[major_version_offset], (size_t)dataBuffer[minor_version_offset], (const char *)&dataBuffer[string_offset]);
        }
      }
      break;
    case STRING_DATA:
      if (currentStringCallback) {
        const size_t string_offset = 1;
        const size_t end_of_string = (string_offset + decodeByteStream((sysexBytesRead - string_offset), &dataBuffer[string_offset]));
        bufferDataAtPosition('\0', end_of_string); // NULL terminate the string
        (*currentStringCallback)(currentStringCallbackContext, (const char *)&dataBuffer[string_offset]);
      }
      break;
    default:
      if (currentSysexCallback)
        (*currentSysexCallback)(currentSysexCallbackContext, dataBuffer[0], sysexBytesRead - 1, dataBuffer + 1);
  }
}

/**
 * Resets the system state upon a SYSTEM_RESET message from the host software.
 * @private
 */
void FirmataParser::systemReset(void)
{
  size_t i;

  waitForData = 0; // this flag says the next serial input will be data
  executeMultiByteCommand = 0; // execute this after getting multi-byte data
  multiByteChannel = 0; // channel data for multiByteCommands

  for (i = 0; i < dataBufferSize; ++i) {
    dataBuffer[i] = 0;
  }

  parsingSysex = false;
  sysexBytesRead = 0;

  if (currentSystemResetCallback)
    (*currentSystemResetCallback)(currentSystemResetCallbackContext);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  th: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\Default
Edge Browser
	Install Path: C:\Program Files (x86)\Microsoft\Edge\Application\MicrosoftEdge.exe
	Version: 
EdgeChromium Browser
	Browser not found
Opera Browser
	Install Path: C:\Users\bluep\AppData\Local\Programs\Opera\launcher.exe
	Version: 72.0.3815.186
	Data Path: C:\Users\bluep\AppData\Roaming\Opera Software\Opera Stable
SafeZone Browser
	Browser not found
SecureBorwser
	Browser not found
		Profile: Default
11.01.2021 14:32:51
BCUEngine version : 18.0.895.0
ProductVersion    : 20.10.2442
ProductLanguage   : en
OSLanguage        : en-us
Location          : en-us
OSType            : 10.0
IsStandalone      : 0
PartnerId         : avastbcl
Priority          : 0
UserSID           : S-1-5-21-1547691233-1674551851-3720732266-1002
silentmode_enabled		: 0
Microsoft IE
	Install Path: C:\Program Files\Internet Explorer\IEXPLORE.EXE
	Version: 11.630.19041.0
Mozilla Firefox Browser
	Browser not found
Google Chrome Browser
	Version: 87.0.4280.141
	Install Path: C:\Program Files\Google\Chrome\Application\chrome.exe
	Profile Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\
Google Chrome Profiles
	Name: Default Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\Default
Edge Browser
	Install Path: C:\Program Files (x86)\Microsoft\Edge\Application\MicrosoftEdge.exe
	Version: 
EdgeChromium Browser
	Browser not found
Opera Browser
	Install Path: C:\Users\bluep\AppData\Local\Programs\Opera\launcher.exe
	Version: 72.0.3815.186
	Data Path: C:\Users\bluep\AppData\Roaming\Opera Software\Opera Stable
SafeZone Browser
	Browser not found
SecureBorwser
	Browser not found
		Profile: Default
11.01.2021 14:32:51
BCUEngine version : 18.0.895.0
ProductVersion    : 20.10.2442
ProductLanguage   : en
OSLanguage        : en-us
Location          : en-us
OSType            : 10.0
IsStandalone      : 0
PartnerId         : avastbcl
Priority          : 0
UserSID           : S-1-5-21-1547691233-1674551851-3720732266-1002
silentmode_enabled		: 0
Microsoft IE
	Install Path: C:\Program Files\Internet Explorer\IEXPLORE.EXE
	Version: 11.630.19041.0
Mozilla Firefox Browser
	Browser not found
Google Chrome Browser
	Version: 87.0.4280.141
	Install Path: C:\Program Files\Google\Chrome\Application\chrome.exe
	Profile Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\
Google Chrome Profiles
	Name: Default Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\Default
Edge Browser
	Install Path: C:\Program Files (x86)\Microsoft\Edge\Application\MicrosoftEdge.exe
	Version: 
EdgeChromium Browser
	Browser not found
Opera Browser
	Install Path: C:\Users\bluep\AppData\Local\Programs\Opera\launcher.exe
	Version: 72.0.3815.186
	Data Path: C:\Users\bluep\AppData\Roaming\Opera Software\Opera Stable
SafeZone Browser
	Browser not found
SecureBorwser
	Browser not found
		Profile: Default
11.01.2021 14:32:51
BCUEngine version : 18.0.895.0
ProductVersion    : 20.10.2442
ProductLanguage   : en
OSLanguage        : en-us
Location          : en-us
OSType            : 10.0
IsStandalone      : 0
PartnerId         : avastbcl
Priority          : 0
UserSID           : S-1-5-21-1547691233-1674551851-3720732266-1002
silentmode_enabled		: 0
Microsoft IE
	Install Path: C:\Program Files\Internet Explorer\IEXPLORE.EXE
	Version: 11.630.19041.0
Mozilla Firefox Browser
	Browser not found
Google Chrome Browser
	Version: 87.0.4280.141
	Install Path: C:\Program Files\Google\Chrome\Application\chrome.exe
	Profile Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\
Google Chrome Profiles
	Name: Default Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\Default
Edge Browser
	Install Path: C:\Program Files (x86)\Microsoft\Edge\Application\MicrosoftEdge.exe
	Version: 
EdgeChromium Browser
	Browser not found
Opera Browser
	Install Path: C:\Users\bluep\AppData\Local\Programs\Opera\launcher.exe
	Version: 72.0.3815.186
	Data Path: C:\Users\bluep\AppData\Roaming\Opera Software\Opera Stable
SafeZone Browser
	Browser not found
SecureBorwser
	Browser not found
		Profile: Default
11.01.2021 14:32:51
BCUEngine version : 18.0.895.0
ProductVersion    : 20.10.2442
ProductLanguage   : en
OSLanguage        : en-us
Location          : en-us
OSType            : 10.0
IsStandalone      : 0
PartnerId         : avastbcl
Priority          : 0
UserSID           : S-1-5-21-1547691233-1674551851-3720732266-1002
silentmode_enabled		: 0
Microsoft IE
	Install Path: C:\Program Files\Internet Explorer\IEXPLORE.EXE
	Version: 11.630.19041.0
Mozilla Firefox Browser
	Browser not found
Google Chrome Browser
	Version: 87.0.4280.141
	Install Path: C:\Program Files\Google\Chrome\Application\chrome.exe
	Profile Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\
Google Chrome Profiles
	Name: Default Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\Default
Edge Browser
	Install Path: C:\Program Files (x86)\Microsoft\Edge\Application\MicrosoftEdge.exe
	Version: 
EdgeChromium Browser
	Browser not found
Opera Browser
	Install Path: C:\Users\bluep\AppData\Local\Programs\Opera\launcher.exe
	Version: 72.0.3815.186
	Data Path: C:\Users\bluep\AppData\Roaming\Opera Software\Opera Stable
SafeZone Browser
	Browser not found
SecureBorwser
	Browser not found
		Profile: Default
11.01.2021 14:34:08
BCUEngine version : 18.0.895.0
ProductVersion    : 20.10.2442
ProductLanguage   : en
OSLanguage        : en-us
Location          : en-us
OSType            : 10.0
IsStandalone      : 0
PartnerId         : avastbcl
Priority          : 0
UserSID           : S-1-5-21-1547691233-1674551851-3720732266-1002
silentmode_enabled		: 0
Microsoft IE
	Install Path: C:\Program Files\Internet Explorer\IEXPLORE.EXE
	Version: 11.630.19041.0
Mozilla Firefox Browser
	Browser not found
Google Chrome Browser
	Version: 87.0.4280.141
	Install Path: C:\Program Files\Google\Chrome\Application\chrome.exe
	Profile Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\
Google Chrome Profiles
	Name: Default Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\Default
Edge Browser
	Install Path: C:\Program Files (x86)\Microsoft\Edge\Application\MicrosoftEdge.exe
	Version: 
EdgeChromium Browser
	Browser not found
Opera Browser
	Install Path: C:\Users\bluep\AppData\Local\Programs\Opera\launcher.exe
	Version: 72.0.3815.186
	Data Path: C:\Users\bluep\AppData\Roaming\Opera Software\Opera Stable
SafeZone Browser
	Browser not found
SecureBorwser
	Browser not found
		Profile: Default
11.01.2021 14:34:08
BCUEngine version : 18.0.895.0
ProductVersion    : 20.10.2442
ProductLanguage   : en
OSLanguage        : en-us
Location          : en-us
OSType            : 10.0
IsStandalone      : 0
PartnerId         : avastbcl
Priority          : 0
UserSID           : S-1-5-21-1547691233-1674551851-3720732266-1002
silentmode_enabled		: 0
Microsoft IE
	Install Path: C:\Program Files\Internet Explorer\IEXPLORE.EXE
	Version: 11.630.19041.0
Mozilla Firefox Browser
	Browser not found
Google Chrome Browser
	Version: 87.0.4280.141
	Install Path: C:\Program Files\Google\Chrome\Application\chrome.exe
	Profile Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\
Google Chrome Profiles
	Name: Default Path: C:\Users\bluep\AppData\Local\Google\Chrome\User Data\Default
Edge Browser
	Install Path: C:\Program Files (x86)\Microsoft\Edge\Application\MicrosoftEdge.exe
	Version: 
EdgeChromium Browser
	Browser not found
Opera Browser
	Install Path: C:\Users\bluep\AppData\Local\Programs\Opera\launcher.exe
	Version: 72.0.3815.186
	Data Path: C:\Users\bluep\AppData\Roaming\Opera Software\Opera Stable
SafeZone Browser
	Browser not found
SecureBorwser
	Browser not found
		Profile: Default
11.01.2021 14:34:08
BCUEngine version : 18.0.895.0
ProductVersion    : 20.10.2442
ProductLanguage   : en
OSLanguage        : en-us
Location          : en-us
OSType            : 10.0
IsStandalone      : 0
PartnerId         : avastbcl
Priority          : 0
UserSID           : S-1-5-21-1547691233ASU!VPSz !U   …  È  xÚ=Øw<Vß ğkŒ"e'QÉø>ñ Œ²"ëAøÙdl!{”QVddJdô de“MÙ"£2¾V²ãçù¾^çşãuŞçŞ{îŸó9÷¡¥#wñÓÑá[£Bİd9=‚ F<ˆ_üÀ*­áïÑ„=Dö{G³_Î+ZâcãNcåÕmÀoáş‘DgÁÊñ7—õL"	Nómbìeˆİ\_¢¿Œ Ù9gp¿ôÅák„«íSdaó›}š}VãûFaŞÎz®ğËD,ıq?ÂÂH¨©<#¥0âTí™É{’K—ÎûM=ö™ÖÖé˜_×Ú¤{­È\$Hòh;[ärXPçN¸`Ùñ–ÍºkŸvAá:·6×a¬Ş¨ò³¾•(ÂóÊYQ#îVÚ=I‰Ç.ûªXŞägë¶3{1ƒğ<9gí5yó*oÉ#Y«XUïm&Ÿ»±(÷#+ì¸½a’òmaì!×+ÂóÄsÔÜC?m¤ï\´Ï#¼/DøÕßç½Š]ª­•ø¯Dâz¥ÜŞm‰ë—‡g0~ÏÄS
}åqÎ¤5´ÇÏ×FŸÏ÷¹cí¢TKx_b`>å2éÕ¨âfB{z{·¨R7ˆ|±Óc„ùÒJØØ®ïÃ¾^«7E±“ĞJ¼×Ø§âoW¯ësß&RÏ%JƒÖ¤yNTµ&à0%şc±"Íëù™ä@7Í	:/ô=©U®Ï6ôæÙ  ı½5	ÚÖ•„‚]ÚSºÆ‰Š2ã ¼šì‘åÚ\Ú4±×¥	®Cºrê5ß;=t²ûš

,tdá=Z§&9hÁBZzú~¡O2§×9õ¡‹wUOÙVè¸$…3XÁĞmøKô•µ' _ùü`¸~¥ªZïa“ÙÂC<tâÛQ–v·Thõ@=6’Ÿ¡o=üÌ¶ÙL
]p¦æÒE'óĞ¶öW®Z¡ıßÖÈ¾"#Íê ={İ»«ã ZÄ©â*[é(ô9Œ‚Õ<ş7´X©¿MÈßĞéˆ°8ÅèEaM™nhÒw¸kcÍŠ¡Ğ_<›£HÙ‚>åÈ„-Åˆ ëİı÷;t_-İ¢s#AÀü9tk9¯´ù¡Š+º¾}2Òßk¥Ì [ânFnEEB?ÔÈ•÷-I€Æ$d*º¾7W…N}¡Üf‰¶?¶¨§ú¹[óOÕjb‡ĞÑ7Õ/?Ûs†>Ys_c7‘}ÔvYS˜ï}rPƒ5»
3I†›a¶>İ7©©µö4Kš¤VùîÏ8:_—ŸŞ]Y©I… MÕz·ı]o;ƒ±Ôfh›¦`Ã§©Ñxlol Da®oDq˜i²=4ç>•É­fóèg‹a¦	_)¿Bç–e™™M[@;Å[
‡Š.£ûw±ÒÒ>±ğ/ô_ck¡¹ÏĞ/.[ÙloVÛA?f²å(0—†ösr´?ÔĞ˜†&Jõw`²AÇ«¹…q|Ö«Š®Gd–ë)£èy±Gn§*Ø %Kº90Oò@—«k»ow»ô@/Œˆz×O?œ„öŞõa}ú]ÿ¡ô§¾Sşåèş›ÿŸŸå‘şŸrc)½C#VƒöÇ{¡]5m‚ÃÖÚÑøá)VóCó›²q{(ı]€ƒ¾Û–GŞĞ·gì‘nÆè~ì§ÇÆUFĞùÕØz\ÿâ<šßˆ#±´5ĞÃ»’OâÃä¡cúŠ”SÎ¡Î—Œ-â
G÷7WÔÍØÆÑ}Iè™8J9tş¦‚ã¶J2Ñøúéø.Næ*š¿òãmwËI ÿ¥íŒ¯UwAóßû±çÉùñß~A·üït*iR^´).3M(%
½«›nb”ˆæßğ¯|¬?vé¯3Ş¢ï£ºı¶‹şŸtôü˜V/hYŸ‚®^¶/Én¨DãİŸ‹ÏØC÷s­+şÀ×Í?8±şRê[t¡™ë/–MË£ñ´6ı¡æ Í·4nÜ"Ã)Ğ»á·+¶o4£ûÙ³[«ÒëŒ#šÿ
{j«Ï^EÑıºP\‘o„ö—““­ö>öš/Ì-êÈ2)
 ÉIµÔ¿¢ùkAIµ©Rüö,ôAæbóZ;4?‡oİmiéhƒæ?ğl÷lœ¿ıR=¦cËÚú;šO»*~«C_kë¢¸°ÿº.\«ûíà :Şdø´fôüˆ—êíIşí„gn•×û®Ï¡ëW3=3ØÑ^Pç¼#b:Ş çóëã+˜rô<Á|1™J1õ€.ëvø–MîÇ Şøo{ÊŞÊhœªg6$¾£óElØ?Ã°{!:?üÌó¡ :íå|sIF¡\h¾&›7‰Fãı|ñ|í-+
èñÇ˜kK&t~èÅm–ĞıÊ¢ºdòé4´Ì…õ¥Yçqôû§+Õy9"ÊÍÚÌ¦wY6ÙşşçÕ*=Ù}h,	÷:³\K=:>3õï£h,4ÇäƒMòsÿ ç¯ŞãÍ&2WZh91²­ÊsDh<&­mpµ‚6 ‹İfù…~oaH:h¶ÑïWÓƒË¾Ğ,ÿšwv£óÖ÷°0N,ZÔùÇá†%õu‚?Êoš$CzªA;/g	ß›+¯œz‰0µƒŠ=™;dÉÇñÄ°Â–ÌgÁ¥~Sˆoü¸N‚ˆ„ÜØ,ÖoZï	3¸§uXòâŠ²Œ3	…OÄ/’ñFƒñ—ßjLn™ù6ÊLf1•âdÎå—@ØkëlëÁæ‡­â‰må£DèChÒ•òsä…†Áş‚ÃW‘še³;}úqK•@2ã$wÀØÔ_®Ù‘<qb*ß—n3¿#AíıN´ëû0ñŠÕh»WbGè”@zôo¦YÊÆXLrîƒÜsàb/«á“ÂÌN_×òÿ$p0–Î1¢à‹ñ\JËü'p.s´n¥Õ³‘)QídƒôMå‹3†|æ÷
ß> ùòl—Nœ~Õ6q©d×9„ào®_Št²4ë®çãË74?)“®TMÜ£»óÁöÌ®„øc€ğWÜ¡‰Ÿª–û]—
È)êbN=JŸéGäi-ß3¨¼º]R SX­T…ú2¿Ó~æn±x-¥	&S_gÛ¬=p52·À€‰¾…=…u˜‹‘–>@6ï5z¨ÉíÖ]™ÏAÀ€]Ô0·xTûhD¿ÔÌJªb«O®éÇş¤aöšœ¯±9D“$?.-¥‚[ìTâ­«û=C+«k«êw©·œÄíUî?6—‚æ(Ád¹T±¥ŒŠÊSÆ&¢š!£ÛÇœœ7¹“9_eŒFZenÄµùÉ´`ÅâO™±Ç\B~/¿ÿØõéã"²ş|ÙIgFí‹ø ùìï›33e¯¨4íÎgƒ´“)·Öúœ7
9Î¹hÇşªÏŠG¡w§/sóI‚qv.%_ñw×÷šdFÍÜ}×>¥…Y|jTÉ$PóĞ(OfíR=Xî›]F@NF¬–éñQ™ºañÍ`"}×Aå¦BêºÃ›K¢ÀË†R?£«ŞPíĞñ|ëë °kl¡¯J,Ig¥Àa¡Ê|°)Ãìş]Ø¿R)ÌP6p+¶Õó¹‚lÃ-È=WsÀ“xÓÑY·êvT“2ÿH¯;’ïs	¨ø-úè	sĞKG`‡Ã»í*®	éõ—KD–‚l‘&·ûlT»g'·Y¤A]÷Œ{Y]ZÊü¨¯“ì x³ãå‘°Oœ|nZÁ\es®z9Q>! õê¦zxlÔè{çD!m»œÀHè›}SÙT)ƒ¿¬î™±iíª€EÖêí/_o"#¼ªA¢|¢Y[?nˆgƒO²½á,Ø'"Ø>³üCõ\à_‰|QıÈ»"ûNÊø| cøí‰4çésª“a½½ÈF)óS}eb“ÉRéVbL˜T~šük\4Ú£fÉw6ÄôwÄ<3Û1PcLWÎï—c-W˜´}÷°"yµ*@Y9?.S µM\°–HÆé"xß_±¿WÈÛ’*8GmŸ¤rfÓÖí7¦fu/ŸQpéÚ§í÷9øÈO îû-‰á-ÙÅø(™öIÏ@I’v_I¨3	`0ûô¼+{y>j]W¸¬üxşÁs¶GNNj«jpdÍ$—-Ô+Fª¿Z+›Èîç¬’{ÌL«æ•$Á´BH5İËó’‚?ä*